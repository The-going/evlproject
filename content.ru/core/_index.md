---
title: "Ядро EVL"
menuTitle: "Ядро реального времени"
date: 2019-02-16T16:10:44+01:00
weight: 5
pre: "&#8226; "
original_path: "content/core/_index.md"
original_hash: "c56874c"
---

## Сила ядра EVL в реальном времени

Для определенных типов приложений выгрузка определенного набора критически важных
по времени задач в автономное программное ядро, встроенное в ядро Linux, может
обеспечить наилучшую производительность при минимальных затратах на разработку
и время выполнения по сравнению с наложением поведения в реальном времени на
всю логику ядра, чтобы уложиться в сроки, установленные только для этих задач,
как того требует модель [native
preemption](https://wiki.linuxfoundation.org/realtime/rtl/blog).

В двух словах, проект Xenomai 4 посвящен внедрению простой, масштабируемой и
надежной архитектуры с двумя ядрами для Linux, основанной на
[интерфейсе Dovetail]({{% relref "dovetail/_index.md" %}}) для подключения
высокоприоритетного программного ядра к основному ядру. Этот интерфейс
демонстрируется ядром реального времени, предоставляющим базовые услуги приложениям
с помощью  [простого API]({{% relref "core/user-api/_index.md" %}}).
Ядро EVL - это непрерывное развитие готовой к производству инфраструктуры
реального времени, которая также может стать отправной точкой для других
разновидностей выделенного программного ядра, встроенного в ядро Linux.
Эта работа состоит из:

- интерфейс [Ласточкин хвост - Dovetail]({{% relref "dovetail/_index.md" %}})
  который вводит этап выполнения с высоким приоритетом в основную логику ядра,
  где выполняется функционально независимое программное ядро.

- ядро EVL, которое обеспечивает надежные сервисы с низкой задержкой для
  приложений, которые должны соответствовать требованиям реального времени.
  Приложения разрабатываются с использованием общей модели программирования Linux.

- подробная документация, которая охватывает как "Ласточкин хвост", так и ядро
  EVL, с множеством перекрестных ссылок между ними, так что инженеры могут
  использовать ядро EVL для поддержки приложения в реальном времени, улучшать
  его или даже реализовывать собственное программное ядро по выбору поверх
  Dovetail на практическом примере.

{{% notice info "Примечание переводчика" %}}
Здесь и далее англоязычное написание слова Dovetail и его перевод "Ласточкин хвост"
будут фигурировать в обоих вариантах случайным образом.
{{% /notice %}}

То, что мы ищем:

- Низкие затраты на проектирование и техническое обслуживание. Работа над EVL
  должна требовать только общих знаний о разработке ядра, а объем и сложность кода
  должны оставаться приемлемыми для небольших команд разработчиков (в настоящее
  время около 20 KLOC, что даже вдвое меньше размера ядра
  [Xenomai 3 Cobalt](https://git.xenomai.org/xenomai/-/wikis/home).

- Низкая стоимость выполнения. Надежное, сверхнизкое и ограниченное время отклика
  для рабочей нагрузки в реальном времени, в том числе на низкоуровневом одноядерном
  оборудовании с минимальными накладными расходами, оставляя много циклов процессора
  для одновременного выполнения рабочей нагрузки общего назначения.

- Высокая масштабируемость. От одноядерных до высокопроизводительных многоядерных
  машин, выполняющих рабочие нагрузки в режиме реального времени параллельно с
  низкой и ограниченной задержкой. Выполнение этих рабочих нагрузок на
  [изолированных процессорах]({{< relref "core/caveat.md#isolcpus" >}})
  значительно улучшает
  [показатель наихудшей задержки]({{< relref "core/benchmarks/_index.md#stress-load" >}})
  в конфигурациях SMP, но если в вашем устройстве есть только один из них,
  ядро EVL все равно должно обеспечивать сверхнизкую и ограниченную задержку.

- Небольшая конфигурация. Мы хотим, чтобы требовалось совсем немного настроек
  во время выполнения, для обеспечения того, чтобы рабочая нагрузка в режиме
  реального времени не зависела от обычной рабочей нагрузки общего назначения.
  После включения в конфигурации ядра Linux, ядро EVL должно быть готово к доставке.

## Сделай это обычным, сделай это простым

Ядро EVL - это специализированное программное ядро, встроенное в ядро,
предоставляющее услуги в режиме реального времени приложениям с жесткими
требованиями к времени выполнения. Это небольшое ядро построено как любая
обычная функция ядра Linux, а не как внешнее расширение, наложенное поверх него.
[Dovetail]({{% relref "dovetail/_index.md" %}}) играет здесь важную роль,
поскольку он скрывает мелкие детали встраивания сопутствующего ядра в ядро Linux.
Его довольно низкий объем кода и ограниченная сложность делают его хорошим выбором
в качестве инфраструктуры реального времени "подключи и забудь", которая также
может быть использована в качестве отправной точки для пользовательских
реализаций ядра. Следующие цифры были получены с помощью инструмента
[CLOC](https://github.com/AlDanial/cloc) подсчитывающего строки исходного кода из
[RTAI](http://rtai.org),
[Xenomai 3 Cobalt](https://git.xenomai.org/xenomai/-/wikis/home)
и [Xenomai 4 EVL](https://evlproject.org/core) реализации ядра соответственно:

![Alt text](/images/kloc-core.png "Объем кода ядра EVL")

Интерфейсом пользовательского пространства для этого ядра является
[библиотека EVL]({{% relref "core/user-api/_index.md" %}}) (`libevl.so`),
которая реализует базовые оболочки системных вызовов, а также основные службы
синхронизации потоков. Никаких наворотов и свистков, только основы. Цель состоит
в том, чтобы обеспечить простые механизмы, а сложную семантику и политики,
которые могут и должны быть реализованы на основе этой библиотеки, в API
высокого уровня, работающего на стране пользователей.

![Alt text](/images/kloc-user.png "Размер пользовательского кода EVL")

## Elements {#evl-core-elements}

Как следует из названия, _elements_ -это основные функции, которые могут
потребоваться от ядра EVL для поддержки приложений реального времени в этой среде
с двумя ядрами. Кроме того, только ядро EVL в состоянии эффективно предоставлять
такие функции, чистый код пользовательского пространства не может их предоставить.
Ядро EVL определяет шесть элементов:

- [Thread]({{< relref "core/user-api/thread/_index.md" >}})(поток или нить)
  как основная исполнительная единица, и мы хотим, чтобы она выполнялась либо в
  режиме реального времени, либо в обычном режиме операционной системы общего
  назначения, в качестве альтернативы, что точно соответствует внеполосному и
  внутриполосному контекстам [Dovetail]({{% relref "dovetail/pipeline/_index.md" %}}).

- Монитор. Этот элемент имеет ту же цель, что и _futex_ основного ядра, который
  заключается в предоставлении интегрированного, хотя и гораздо более простого
  набора основных функций синхронизации потоков. Мониторы используются внутренне
  библиотекой EVL для реализации мьютексов,
  [переменных условий]({{< relref "core/user-api/event/_index.md" >}}),
  [групп флагов событий]({{< relref "core/user-api/flags/_index.md" >}}) и
  [семафоров]({{< relref "core/user-api/semaphore/_index.md" >}}) в пространстве
  пользователя.

- [Clock]({{< relref "core/user-api/clock/_index.md" >}})(часы). Мы можем найти
  тактовые устройства, зависящие от платформы, в дополнение к основным,
  определенным архитектурой, для которых должны быть написаны специальные
  драйверы. Элемент 'clock' гарантирует, что все драйверы часов представляют
  один и тот же интерфейс для приложений в пространстве пользователя. Кроме того,
  этот элемент может экспортировать отдельные программные таймеры в приложения,
  что удобно для запуска периодических циклов или ожидания одноразовых событий в
  определенное время.

- [Observable]({{< relref "core/user-api/observable/_index.md" >}})(Наблюдаемый).
  Этот элемент является строительным блоком, который приложения, управляемые
  событиями, могут использовать для реализации
  [шаблона проектирования наблюдателя](https://en.wikipedia.org/wiki/Observer_pattern),
  в котором любое количество потоков наблюдателей может быть уведомлено об
  обновлениях любого количества наблюдаемых объектов в слабо связанной форме.

- [Кросс-буфер]({{< relref "core/user-api/xbuf/_index.md" >}}). (Он же _xbuf_) -это
  двунаправленный канал связи для обмена данными между внеполосными и
  внутриполосными контекстами потоков без влияния на производительность
  в реальном времени на внеполосной стороне. Любой поток (EVL или обычный) может
  ждать/опрашивать ввод с другой стороны. Кросс-буферы служат той же цели, что и
  _каналы сообщений_ Xenomai 3, реализованные с помощью протокола сокетов _XDDP_.

- [Файловый прокси]({{< relref "core/user-api/proxy/_index.md" >}}).
  Двухъядерные системы на базе Linux неприятны по своей конструкции: огромный
  набор функций объектов групповой политики всегда виден приложениям, но они не
  должны использовать его, когда они выполняют работу в режиме реального времени
  с помощью автономного ядра, иначе они рискуют неограниченным временем отклика.
  Из-за такого исключения выдача запросов на ввод/вывод файлов, таких как вызов
  [printf(3)](http://man7.org/linux/man-pages/man3/printf.3.html) не должна
  выполняться непосредственно из критических по времени циклов. Файловый
  прокси-сервер решает такую проблему, перегружая операции ввода-вывода для
  внутриполосных операций с файлами выделенным работникам, одновременно удерживая
  вызывающего абонента на этапе внеполосного выполнения.

## Все это файл {#everything-is-a-file}

Каждый ресурс, экспортируемый EVL в приложения, представлен файлом. Кроме того,
каждый элемент EVL связан с объектом устройства ядра:

- Поскольку все ресурсы EVL поддерживаются внутренним файлом ядра, тяжелая
  работа по управлению их временем жизни, предотвращению устаревших ссылок путем
  отслеживания их пользователей, остается на
  [VFS](https://www.kernel.org/doc/Documentation/filesystems/vfs.txt).

- Приложения могут создавать
  [общедоступные или частные элементы]({{< relref "core/user-api/_index.md#element-visibility" >}}).
  Общедоступный элемент отображается в
  [иерархии файлов]({{< relref "core/user-api/_index.md#evl-fs-hierarchy" >}})
  устройств EVL, что позволяет
  [приложениям с несколькими процессами]({{< relref "core/user-api/_index.md#multi-process-apps" >}})
  совместно использовать элементы.

- Элементы EVL извлекают выгоду из логики управления разрешениями, мониторинга и
  аудита, которые поставляются с семантикой файлов.

- [правила `udev`]({{< relref "core/user-api/_index.md#device-ownership-and-access" >}})
  могут быть привязаны к представляющим интерес событиям, которые могут произойти
  для любого элемента. Кроме того, внутреннее состояние ядра элементов
  экспортируется в пространство пользователя через файловую систему `/sys`.

## Драйверы устройств EVL являются (почти) распространенными драйверами

EVL не вводит какую-либо конкретную модель драйвера. Он экспортирует выделенный
[API ядра]({{%relref "core/kernel-api/_index.md" %}}) для реализации операций
ввода-вывода в реальном времени в общих драйверах символьных устройств.
Фактически, ядро EVL состоит из набора таких драйверов, реализующих каждый класс
элементов.

EVL также предоставляет возможность расширить существующие семейства протоколов
сокетов с помощью возможностей внеполосного ввода-вывода или добавить свои
собственные протоколы с помощью нового семейства  PF_OOB.

---

{{<lastmodified>}}
