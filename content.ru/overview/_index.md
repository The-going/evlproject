---
title: "Обзор"
menuTitle: "Начало"
weight: 1
pre: "&#8226; "
---

{{% notice info %}}
**Проект EVL теперь называется Xenomai 4.** Ядро EVL изначально было развилкой
ядра [Xenomai 3 Cobalt](https://git.xenomai.org/xenomai/-/wikis/home),
которое прошло значительную модернизацию, чтобы сделать его SMP-масштабируемым,
более простым в освоении и обслуживании. Однако
оба они по-прежнему придерживаются одних и тех же принципов, когда речь заходит о
технике двойного ядра. Проект Xenomai внедряет интерфейс конвейера EVL [Dovetail]({{< relref
"dovetail/_index.md" >}}) для своего предстоящего выпуска 3.2.
Таким же образом EVL становится проектом Xenomai 4.
{{% /notice %}}

{{% mixedgrid src="/images/overview-design.png" %}}
**Архитектура с двумя ядрами**. Как и его предшественники в серии Xenomai core,
Xenomai 4 с ядром EVL предоставляет Linux возможности в реальном времени,
встраивая в ядро сопутствующее ядро, которое специально предназначено для задач,
требующих сверхнизкого и ограниченного времени отклика на события.
По этой причине этот подход известен как _двойная архитектура ядра_,
обеспечивающая строгие гарантии в реальном времени для некоторых задач наряду
с богатыми сервисами операционной системы для других. В этой модели ядро общего
назначения (Linux) и ядро реального времени (EVL) работают почти асинхронно,
оба выполняют свой собственный набор задач, всегда отдавая последнему приоритет
над первым.  {{% /mixedgrid %}}

Для достижения этой цели проект Xenomai 4 работает над тремя
компонентами:

- фрагмент внутреннего кода ядра - он же ["Ласточкин хвост"]({{< relref "dovetail/_index.md" >}}), который действует как интерфейс между сопутствующим ядром и ядром общего назначения. Этот слой вводит [этап выполнения с высоким приоритетом]({{< relref "dovetail/pipeline/_index.md#two-stage-pipeline" >}}), на котором должны выполняться задачи с требованиями реального времени. Другими словами, с помощью кода "Ласточкин хвост" ядро Linux может планировать выполнение внеполосных задач в отдельном контексте выполнения, который не подчиняется общим формам сериализации, которым должна соответствовать работа общего назначения (например, маскировка прерываний, блокировки).

- компактное и масштабируемое [ядро реального времени]({{< relref "core/_index.md" >}}), которое предназначено для использования в качестве эталонной реализации для других систем с двумя ядрами, основанных на Dovetail.

- библиотека, известная как [libevl]({{< relref "core/user-api/_index.md" >}}), которая позволяет вызывать основные службы в реальном времени из приложений.

Первоначально кодовая база "Ласточкин хвост" ответвилась от интерфейса [I-pipe](https://git.xenomai.org/xenomai/wikis/home) еще в 2015 году, в основном для решения [фундаментальных проблем обслуживания](https://xenomai.org/pipermail/xenomai/2018-June/039002.html), которые касаются отслеживания самых последних выпусков ядра. Параллельно упрощенный вариант [Cobalt core](https://xenomai.org/documentation/xenomai-3/html/xeno3prm/group__cobalt__core.html) когда-то известный как 'Steely', был реализован для того, чтобы свободно экспериментировать с ласточкиным хвостом, поскольку последний значительно отличался от интерфейса I-pipe.
В какой-то момент 'Steely' превратился в еще более простое, базовое и масштабируемое ядро реального времени, которое теперь служит эталонной реализацией для "Ласточкин хвост", известное как [EVL core]({{< relref "/core/_index.md" >}}), которое сегодня лежит в основе усилий Xenomai 4.

### Когда архитектура с двумя ядрами хорошо подходит?

Система с двумя ядрами должна обеспечивать минимальное функциональное перекрытие между ядром общего назначения и сопутствующим ядром только для того, чтобы передать критическую по времени рабочую нагрузку выделенному компоненту, который прост и достаточно отделен от остальной системы, чтобы вы могли доверять.
Типичные приложения, которые лучше всего обслуживаются такой инфраструктурой, должны получать данные с внешних устройств с небольшим дрожанием в течение нескольких десятых микросекунд (абсолютный [наихудший случай]({{< relref "core/benchmarks/_index.md#stress-load" >}})) как только они будут доступны, обработайте такой ввод через потоки POSIX, которые могут удовлетворять требованиям в реальном времени, выполняя [этап с высоким приоритетом]({{< relref "dovetail/altsched.md" >}}), разгружая любую некритичную (по времени) работу в общие потоки.
Вообще говоря, такой подход, как реализация ядра EVL, может хорошо подойти для этой работы в следующих случаях:

- если вашему приложению требуется сверхнизкое время отклика и/или строго
  ограниченное дрожание надежным способом. Надёжным - это значит
  &laquo;не подверженным влиянию какого-либо кода ядра или пользовательского кода,
  ядро общего назначения способно работать параллельно таким образом, который может
  не допустить соблюдения жестких сроков в реальном времени&raquo;.
  Допустимый код в этом случае означает, что он не вызывает сбоев машины;
  сопутствующее ядро двухъядерной системы не чувствительно к замедлениям,
  которые могут быть вызваны плохо написанными драйверами общего назначения.
  Например, рабочая нагрузка с низким приоритетом способна создать нагрузку на
  подсистему кэширования ЦП, вызывая задержки для действий в реальном времени,
  когда она возобновляется для обработки какого-либо внешнего события:

  - если эта рабочая нагрузка непрерывно обрабатывает большой набор данных,
    что приводит к частым удалениям кэша. Поскольку внешний кэш в иерархии
    разделяется между процессорами, эффект пульсации существует для всех из них,
    включая [изолированные](https://elinux.org/CPU_Shielding_capability).

  - если эта рабочая нагрузка включает в себя множество параллельных потоков, вызывающих высокую частоту переключения контекста, что может стать еще хуже, если эти потоки принадлежат разным процессам (т.е. Имеют разные адресные пространства).

	Небольшая площадь выделенного ядра помогает в этом случае, поскольку в управлении системой реального времени в целом задействовано меньше кода и данных, что снижает влияние неблагоприятных условий кэширования. Кроме того, маленькое ядро не обязано соблюдать правила блокировки, налагаемые на код ядра общего назначения при планировании своих потоков. Вместо этого он может в любое время опередить его, основываясь на методе [конвейерная обработка прерываний]({{< relref "dovetail/pipeline/_index.md" >}}), который реализует Ласточкин хвост. Эта [часть информации]({{< relref "core/benchmarks/_index.md#stress-load" >}}) описывает типичные ситуации во время выполнения, когда рабочая нагрузка общего назначения оказывает давление на всю систему, независимо от относительного приоритета ее задач.

- если при проектировании вашей прикладной системы требуется, чтобы путь выполнения в реальном времени был логически изолирован от действий общего назначения путем построения, чтобы не использовать общие критические подсистемы, такие как общий планировщик.

- если обращение к [изоляции ЦПУ](https://elinux.org/CPU_Shielding_capability) для смягчения неблагоприятных последствий, которые может оказать рабочая нагрузка, не связанная с реальным временем, на стороне реального времени, не является вариантом или после тестирования недостаточно подходит для вашего варианта использования. Очевидно, что использование такого трюка с недорогим оборудованием на одноядерном процессоре не сработает, поскольку по крайней мере один неизолированный процессор должен быть доступен ядру для выполнения обязанностей по обслуживанию системы.

- если использование  PREEMTRT не даёт желаемого результата.


### Что требует от вашего приложения архитектура с двумя ядрами? {#dual-kernel-requirements}

Чтобы уложиться в сроки, архитектура с двумя ядрами требует, чтобы ваше
приложение использовало исключительно выделенный интерфейс системных вызовов,
реализуемый ядром реального времени. С ядром EVL этим API является 
[libevl]({{< relref "core/user-api/_index.md" >}}), или любой другой
основанный на нем API высокого уровня, который соблюдает это правило.
Любой обычный системный вызов Linux, выполняемый во время выполнения на этапе
с высоким приоритетом , автоматически [понизит вызывающего абонента]({{< relref
"dovetail/altsched.md#inband-switch" >}}) до этапа с низким приоритетом,
что приведет к потере гарантий в режиме реального времени в процессе.

> Это правило имеет последствия, например, при использовании C++, для чего
> требуется определить набор используемых классов и функций среды выполнения,
> которые могут быть доступны приложению.

Тем не менее, ваше приложение может использовать любую службу из вашей любимой
стандартной библиотеки C/C++ вне критического по времени контекста.

Вообще говоря, четкое разделение рабочей нагрузки в реальном времени от
остальной части реализации в вашем приложении является ключевым. Наличие такого
разделения должно быть эмпирическим правилом, независимо от типа подхода
в реальном времени, в том числе с собственным упреждением, это **крайне важно**
с двухъядерной архитектурой. Кроме того, это требует четкого определения
(нескольких) интерфейсов, которые могут существовать между задачами
реального времени и общего назначения, что, безусловно, правильно.

Основной единицей выполнения, которую ядро EVL распознает для предоставления своих
услуг в пользовательском пространстве, является [поток]({{< relref
"core/user-api/thread/_index.md" >}}), что обычно переводится как
[Потоки POSIX](http://man7.org/linux/man-pages/man3/pthread_create.3.html)
в пространстве пользователя.

### Какой API следует использовать для реализации драйверов устройств реального времени?

Ядро EVL экспортирует [API ядра]({{< relref
"core/kernel-api/_index.md" >}}) для написания драйверов, расширяя интерфейс
драйвера устройства Linux, чтобы приложения могли извлекать выгоду из
внеполосных служб, предоставляемых на этапе выполнения с высоким приоритетом.

Основной единицей выполнения, которую ядро EVL распознает для предоставления своих
услуг в пространстве ядра, является [kthread]({{< relref
"core/kernel-api/kthread/_index.md" >}}), который является обычным
kthread Linux на стероидах EVL.

### Каков объем кода с двойным ядром?

Все цифры, представленные на приведенных ниже диаграммах, были определены
[CLOC](https://github.com/AlDanial/cloc), поддерживая в сравнениях только
исходные файлы языка C и ассемблера.

{{% mixedgrid-small src="/images/cloc-dovetail.png" %}}
> **Размер Dovetail в коде ядра.** Размер кода интерфейса Dovetail добавленого в ядро составляет 7.8 Kloc по состоянию на v5.7-rc5.
Большинство изменений происходит в универсальном ядре и коде драйвера, которые составляют 73% от общего числа. Остальное разделено на ARM, arm64 и x86-специфический код.
Порт, зависящий от архитектуры, в среднем составляет менее 10% от общего количества портов.
{{% /mixedgrid-small %}}

{{% mixedgrid-small src="/images/cloc-evl.png" %}}
> **Размер ядра EVL в коде ядра.** Размер ядра EVL поверх Dovetail составляет 15,2 Kloc. 97% этого кода не зависит от архитектуры. Каждый порт архитектуры составляет 1% от всего остального, что в среднем составляет 163 строки кода. Это показывает, что "Ласточкин хвост" на самом деле отвечает за подавляющее большинство специфичной для архитектуры поддержки, в которой должно нуждаться сопутствующее ядро.
{{% /mixedgrid-small %}}

{{% mixedgrid-small src="/images/cloc-evl-in-kernel.png" %}}
> **Общий объем кода с двумя ядрами.** Общий объем системы с двумя ядрами EVL составляет 26 Kloc, что включает в себя "Ласточкин хвост", ядро EVL и его драйверы, способные работать вне диапазона. Это составляет 0,13% от общей базы кода ядра по состоянию на v5.7-rc5.
{{% /mixedgrid-small %}}

{{% mixedgrid-small src="/images/cloc-ipipe.png" %}}
> **Сравнение отпечатков I-pipe и Ласточкиного хвоста.** Эти цифры сравнивают последнюю [реализацию I-pipe](https://git.xenomai.org/xenomai/wikis/home) доступную на сегодняшний день, на основе ядра v4.19.x с "Ласточкиным хвостом" для v5.7-rc5. Ласточкин хвост предоставляет дополнительные основные сервисы, такие как встроенная поддержка внеполосного планирования задач, которую, как следствие, сопутствующим ядрам не нужно реализовывать для каждой архитектуры ЦП. Код, специфичный для ARM, значительно меньше для Dovetail, благодаря лучшей интеграции логики [конвейера прерываний]({{< relref "dovetail/pipeline/_index.md" >}}) в основное ядро.
{{% /mixedgrid-small %}}

{{% mixedgrid-small src="/images/cloc-evl-vs-xenomai.png" %}} >
> **Сравнение отпечатков ядра Xenomai 3 Cobalt и Xenomai 4 EVL.** Эти цифры сравнивают Cobalt 3.1 с ядром EVL для ядра v5.7-rc5. Резкое сокращение объема кода, отображаемого в ядре EVL, в основном связано с тем, что основное внимание уделяется более простому, но гибкому [набору функций]({{< relref "core/_index.md#evl-core-elements" >}}) и повторному использованию [общей модели драйверов]({{< relref "core/oob-drivers/_index.md" >}}). Кроме того, большая часть кода, специфичного для архитектуры, обрабатывается Dovetail, в отличие от Cobalt, которому все еще приходится иметь дело с мелкими деталями переключения задач, такими как управление FPU.
{{% /mixedgrid-small %}}

### Перенос Ласточкиного хвоста ###

Если вы намерены перенести Ласточкин хвост на:

   - какой-то произвольный вкус ядра или выпуск.

   - неподдерживаемая аппаратная платформа.

   - другая архитектура процессора.

Тогда вы могли бы с пользой использовать следующую информацию:

- прежде всего, процесс разработки EVL описан в этом
  [документе]({{< relref "devprocess.md" >}}). Вам понадобится эта информация,
  чтобы отслеживать разработку EVL, на которой основана ваша собственная работа.

- подробная информация о переносе интерфейса "Ласточкин хвост"
  на другую архитектуру процессора для ядра Linux
  [приведена здесь]({{< relref "dovetail/porting/_index.md" >}}).

- текущая коллекция &laquo; эмпирических правил &raquo; когда она доходит
  до разработки программного обеспечения поверх двухъядерной инфраструктуры EVL.

### Реализация вашего собственного сопутствующего ядра

Если вы планируете разработать собственное ядро для встраивания в ядро Linux
для запуска потоков POSIX на [этапе с высоким приоритетом]({{< relref
"dovetail/pipeline/_index.md#two-stage-pipeline" >}}), введённом Dovetail,
вы можете использовать реализацию ядра EVL в качестве справочного кода
в отношении взаимодействия вашей работы с ядром общего назначения.
Чтобы помочь вам в дальнейшем в этой задаче, вы можете обратиться к следующим
разделам этого сайта:

- все разделы документации, упомянутые ранее о переносе Dovetail.

- описание так называемой [альтернативной схемы планирования]({{< relref
  "dovetail/altsched.md" >}}) схемы, по которой потоки ядра Linux и
  потоки POSIX могут получить доступ к этапу выполнения с высоким приоритетом,
  чтобы воспользоваться гарантиями планирования в реальном времени.

- разрабатываемая серия [технических документов]({{< relref
  "core/under-the-hood/_index.md" >}}), которая проведет вас через
  реализацию ядра EVL.

### Запуск ядра EVL

#### Рецепт для нетерпеливых {#evl-recipe-for-impatient}

1. прочитайте этот [документ]({{< relref "core/build-steps.md" >}}) о создании ядра EVL и libevl.

2. загрузите ядро с поддержкой EVL.

3. напишите свой первый код приложения, используя [API libevl]({{< relref
"core/user-api/_index.md" >}}). Вы можете найти следующие биты
полезными, особенно при обнаружении системы:

	- что влечет за собой [инициализация приложения EVL]({{< relref
 "core/user-api/init/_index.md" >}}).

	- как запустить [потоки POSIX на этапе с высоким приоритетом]({{< relref
 "core/user-api/thread/_index.md" >}}).

	- какой [контекст вызова]({{< relref "core/user-api/function_index/_index.md" >}})
	подходит для каждой службы EVL из этого API.

4. [калибровка]({{< relref "core/runtime-settings.md" >}}) и
   [тестирование]({{< relref "core/testing.md" >}}) системы.

#### Для всех остальных из нас

Процесс запуска ядра EVL в вашей целевой системе можно кратко описать следующим
образом (нажмите на шаги, чтобы открыть соответствующую документацию).:

{{<mermaid align="left">}}
graph LR;
    S("Сборка libevl") --> X["Установка libevl"]
    style S fill:#99ccff;
    click S "/core/build-steps#building-libevl"
    X --> A["Сборка ядра"]
    click A "/core/build-steps#building-evl-core"
    A --> B["Установка ядра"]
    style A fill:#99ccff;
    B --> C["Загрузка цели"]
    style C fill:#ffffcc;
    C --> U["Запуск проверки evl"]
    style U fill:#ffffcc;
    click U "/core/commands#evl-check-command"
    U --> UU{OK?}
    style UU fill:#fff;
    UU -->|Yes| D["Запуск тестов"]
    UU -->|No| R[Исправление Kconfig]
    click R "/core/caveat"
    style R fill:#99ccff;
    R --> A
    style D fill:#ffffcc;
    click D "/core/testing#evl-unit-testing"
    D --> L{OK?}
    style L fill:#fff;
    L -->|Yes| E["Тест с 'hectic'"]
    L -->|No| Z["Отчёт в upstream"]
    style Z fill:#ff420e;
    click E "/core/testing#hectic-program"
    click Z "https://xenomai.org/mailman/listinfo/xenomai/"
    E --> M{OK?}
    style M fill:#fff;
    M -->|Yes| F["Калибровка таймера"]
    M -->|No| Z
    click F "/core/runtime-settings#calibrate-core-timer"
    style E fill:#ffffcc;
    F --> G["Тест с 'latmus'"]
    style F fill:#ffffcc;
    style G fill:#ffffcc;
    click G "/core/testing#latmus-program"
    G --> N{OK?}
    style N fill:#fff;
    N -->|Yes| O["Иди праздновать"]
    N -->|No| Z
    style O fill:#33cc66;
{{< /mermaid >}}

Как только ядро EVL запустится в вашей целевой системе,вы можете перейти
непосредственно к приведённому здесь шагу
[быстрого рецепта]({{< relref "#evl-recipe-for-impatient" >}}).

---

{{<lastmodified>}}
