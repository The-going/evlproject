<!DOCTYPE html>
<html lang="ru" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.89.1" />
    <meta name="description" content="Xenomai 4 project">
    <meta name="author" content="Philippe Gerum &lt;rpm@xenomai.org&gt;">
    
    <title>Биты, зависящие от архитектуры :: Xenomai 4</title>
    <link href="https://the-going.github.io/evlproject/css/nucleus.css?1636572175" rel="stylesheet">
    <link href="https://the-going.github.io/evlproject/css/fontawesome-all.min.css?1636572175" rel="stylesheet">
    <link href="https://the-going.github.io/evlproject/css/featherlight.min.css?1636572175" rel="stylesheet">
    <link href="https://the-going.github.io/evlproject/css/perfect-scrollbar.min.css?1636572175" rel="stylesheet">
    <link href="https://the-going.github.io/evlproject/css/auto-complete.css?1636572175" rel="stylesheet">
    <link href="https://the-going.github.io/evlproject/css/theme.css?1636572175" rel="stylesheet">
    <link href="https://the-going.github.io/evlproject/css/theme-evl-ml.css?1636572175" rel="stylesheet">
    <link href="https://the-going.github.io/evlproject/css/variant.css?1636572175" rel="stylesheet">
    <link href="https://the-going.github.io/evlproject/css/print.css?1636572175" rel="stylesheet" media="print">
    <link href="https://the-going.github.io/evlproject/css/font-mix.css?1636572175" rel="stylesheet">
    <script src="https://the-going.github.io/evlproject/js/jquery.min.js?1636572175"></script>
    <style>
      :root #header + #content > #left > #rlblock_left{
        display:none !important;
      }
        :not(pre) > code + span.copy-to-clipboard {
            display: none;
        }
    </style>
  </head>
  <body class="" data-url="https://the-going.github.io/evlproject/ru/dovetail/porting/arch/">
    <script>
      var index_url="https://the-going.github.io/evlproject/ru/index.json";
      var root_url="https://the-going.github.io/evlproject/";
      var baseUri=root_url.replace(/\/$/, '');
    </script>
    <nav id="sidebar" class="showVisitedLinks">
      <div id="header-wrapper">
        <div id="header">
<a href="https://the-going.github.io/evlproject/"><img src="https://the-going.github.io/evlproject/images/xenomai-logo.png"></a>

        </div>
        <div class="searchbox">
          <label for="search-by"><i class="fas fa-search"></i></label>
          <input data-search-input id="search-by" type="search" placeholder="Поиск...">
          <span data-search-clear=""><i class="fas fa-times"></i></span>
        </div>
        <script src="https://the-going.github.io/evlproject/js/lunr.min.js?1636572175"></script>
        <script src="https://the-going.github.io/evlproject/js/auto-complete.js?1636572175"></script>
        <!-- hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic: -->
        <!-- https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72 -->
        <script src="https://the-going.github.io/evlproject/js/search.js?1636572175"></script>
      </div>
      <div class="highlightable">
        <ul class="topics">
          <li data-nav-id="/ru/overview/" title="Обзор" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/overview/">&#8226; Начало<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/ru/overview/testing-page/" title="Протестируем рендер страницы" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/overview/testing-page/">Тестовая страница<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/ru/core/" title="Ядро EVL" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/">&#8226; Ядро реального времени<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/ru/core/build-steps/" title="Сборка EVL" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/build-steps/">Компиляция EVL<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/core/runtime-settings/" title="Конфигурация времени выполнения" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/runtime-settings/">Уставки времени выполнения<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/core/testing/" title="Тестирование установки" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/testing/">Выполнение тестов<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/core/commands/" title="Команда &#39;evl&#39;" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/commands/">Команды<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/core/benchmarks/" title="Запуск benchmarks" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/benchmarks/">Benchmarking<i class="fas fa-check read-icon"></i></a><ul></ul></li>
          <li data-nav-id="/ru/core/user-api/" title="Using libevl" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/user-api/">&#9702; Application interface<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/ru/core/user-api/function_index/" title="libevl function index" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/user-api/function_index/">Function index<i class="fas fa-check read-icon"></i></a><ul></ul></li>
          <li data-nav-id="/ru/core/user-api/mutex/" title="Mutex" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/user-api/mutex/">Mutex<i class="fas fa-check read-icon"></i></a><ul></ul></li>
          <li data-nav-id="/ru/core/user-api/semaphore/" title="Semaphore" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/user-api/semaphore/">Semaphore<i class="fas fa-check read-icon"></i></a><ul></ul></li>
          <li data-nav-id="/ru/core/user-api/observable/" title="Observable" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/user-api/observable/">Observable<i class="fas fa-check read-icon"></i></a><ul></ul></li>
          <li data-nav-id="/ru/core/user-api/proxy/" title="File proxy" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/user-api/proxy/">File proxy<i class="fas fa-check read-icon"></i></a><ul></ul></li>
          <li data-nav-id="/ru/core/user-api/poll/" title="Polling file descriptors" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/user-api/poll/">Polling file descriptors<i class="fas fa-check read-icon"></i></a><ul></ul></li>
          <li data-nav-id="/ru/core/user-api/io/" title="Out-of-band I/O services" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/user-api/io/">Out-of-band I/O services<i class="fas fa-check read-icon"></i></a><ul></ul></li>
          <li data-nav-id="/ru/core/user-api/misc/" title="Miscellanea" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/user-api/misc/">Misc. services<i class="fas fa-check read-icon"></i></a><ul></ul></li>
          <li data-nav-id="/ru/core/user-api/api-revs/" title="API revisions" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/user-api/api-revs/">API revisions<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/ru/core/caveat/" title="Это вы определенно хотите знать" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/caveat/">Предостережение<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/core/oob-drivers/" title="Real-time I/O drivers" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/oob-drivers/">&#9702; Real-time I/O drivers<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/ru/core/oob-drivers/dma/" title="DMA" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/oob-drivers/dma/">DMA<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/core/oob-drivers/spi/" title="SPI" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/oob-drivers/spi/">SPI<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/core/oob-drivers/gpio/" title="GPIO" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/oob-drivers/gpio/">GPIO<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/ru/core/under-the-hood/" title="Под капотом" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/core/under-the-hood/">&#9702; Под капотом<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/ru/core/under-the-hood/abi/" title="The EVL ABI" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/under-the-hood/abi/">Изменения ABI<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/ru/core/abi-revs/" title="ABI revisions" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/core/abi-revs/">ABI revisions<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/ru/dovetail/" title="Интерфейс Dovetail" class="dd-item parent"><a href="https://the-going.github.io/evlproject/ru/dovetail/">&#8226; Интерфейс Dovetail<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/ru/dovetail/pipeline/" title="Interrupt pipeline" class="dd-item alwaysopen"><a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/">&#9702; Interrupt pipeline<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/ru/dovetail/pipeline/irq_handling/" title="IRQ handling" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/irq_handling/">IRQ handling<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/pipeline/synthetic/" title="Synthetic IRQs" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/synthetic/">Synthetic IRQs<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/pipeline/pipeline_inject/" title="IRQ injection" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/pipeline_inject/">IRQ injection<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/pipeline/interrupt_protection/" title="Interrupt protection" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/interrupt_protection/">Interrupt protection<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/pipeline/stage_push/" title="Installing the out-of-band stage" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/stage_push/">OOB stage installation<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/pipeline/stage_escalation/" title="Stage escalation" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/stage_escalation/">Stage escalation<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/pipeline/locking/" title="Locking" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/locking/">Locking<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/ru/dovetail/porting/" title="Перенос Dovetail" class="dd-item parent alwaysopen"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/">&#9702; Перенос Dovetail<i class="fas fa-check read-icon"></i></a><ul>
          <li data-nav-id="/ru/dovetail/porting/prerequisites/" title="Prerequisites" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/prerequisites/">Prerequisites<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/porting/irqflow/" title="Interrupt flow" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/irqflow/">Interrupt flow<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/porting/atomic/" title="Атомарные операции" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/atomic/">Атомарные операции<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/porting/arch/" title="Биты, зависящие от архитектуры" class="dd-item active"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/arch/">Биты архитектуры<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/porting/timer/" title="Tick devices" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/timer/">Tick devices<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/porting/clocksource/" title="Reading clock sources" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/clocksource/">Clock sources<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/porting/syscall/" title="Syscall path" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/syscall/">Syscall path<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/porting/rawprintk/" title="Raw printk support" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/rawprintk/">Serial debugging<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/porting/misc/" title="Misc" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/misc/">Misc<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/porting/devnotes/" title="Developer&#39;s Notes" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/devnotes/">Developer&#39;s Notes<i class="fas fa-check read-icon"></i></a></li></ul></li>
          <li data-nav-id="/ru/dovetail/altsched/" title="Alternate scheduling" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/altsched/">Alternate scheduling<i class="fas fa-check read-icon"></i></a></li>
          <li data-nav-id="/ru/dovetail/rulesofthumb/" title="Rules Of Thumb" class="dd-item"><a href="https://the-going.github.io/evlproject/ru/dovetail/rulesofthumb/">Rules Of Thumb<i class="fas fa-check read-icon"></i></a></li></ul></li>
        </ul>
        <div id="shortcuts">
          <div class="nav-title"></div>
          <ul>
            <li><a class="padding" href="https://the-going.github.io/evlproject/ru/"><i class='fas fa-home'></i> На главную</a></li>
            <li><a class="padding" href="https://riot.im/app/#/room/#evlproject:matrix.org/"><i class='fas fa-comments'></i> канал RIOT</a></li>
            <li><a class="padding" href="https://xenomai.org/mailman/listinfo/xenomai/"><i class='fas fa-comment-dots'></i> Список рассылки</a></li>
          </ul>
        </div>
        <div id="prefooter">
          <hr/>
          <ul>
            <li>
              <a class="padding">
                <i class="fas fa-language fa-fw"></i>
                <div class="select-style">
                  <select id="select-language" onchange="location = baseUri + this.value;">
                    <option id="en" value="/dovetail/porting/arch/">English</option>
                    <option id="ru" value="/ru/dovetail/porting/arch/" selected>Русский</option>
                  </select>
                  <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                    width="255px" height="255px" viewBox="0 0 255 255" style="enable-background:new 0 0 255 255;" xml:space="preserve">
                    <g>
                      <g id="arrow-drop-down">
                        <polygon points="0,63.75 127.5,191.25 255,63.75" />
                      </g>
                    </g>
                  </svg>
                </div>
              </a>
            </li>
            <li><a class="padding" href="#" data-clear-history-toggle=""><i class="fas fa-history fa-fw"></i> Очистить историю</a></li>
          </ul>
        </div>
        <div id="footer">

        </div>
      </div>
    </nav>
    <div id="body">
      <div id="overlay"></div>
      <div class="padding highlightable">
        <div id="top-bar">
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                <i class="fas fa-bars"></i>
              </a>
            </span>
            <span id="toc-menu"><i class="fas fa-list-alt"></i></span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <meta itemprop="itemListOrder" content="Descending" />
                <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="4" /><a itemprop="item" href="https://the-going.github.io/evlproject/ru/"><span itemprop="name">Xenomai 4</span></a> > </li>
                <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="3" /><a itemprop="item" href="https://the-going.github.io/evlproject/ru/dovetail/"><span itemprop="name">Интерфейс Dovetail</span></a> > </li>
                <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="2" /><a itemprop="item" href="https://the-going.github.io/evlproject/ru/dovetail/porting/"><span itemprop="name">Перенос Dovetail</span></a> > </li>
                <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="1" /><a itemprop="item" href="https://the-going.github.io/evlproject/ru/dovetail/porting/arch/" aria-disabled="true"><span itemprop="name">Биты, зависящие от архитектуры</span></a></li>
            </ol>
          </div>
            <div class="progress">
              <div class="wrapper">
<nav id="TableOfContents">
  <ul>
    <li><a href="#irq-state-virtualization">Виртуализация маски прерывания</a>
      <ul>
        <li><a href="#обеспечение-поддержки-объединенных-состояний-прерывания">Обеспечение поддержки объединенных состояний прерывания</a></li>
      </ul>
    </li>
    <li><a href="#arch-irq-handling">Адаптация кода ассемблера к конвейерной обработке IRQ</a>
      <ul>
        <li><a href="#arch-irq-entry">Запись прерывания</a></li>
        <li><a href="#arch-irq-exit">Прерывание выхода</a></li>
        <li><a href="#fault-exit">Fault exit</a></li>
      </ul>
    </li>
    <li><a href="#reconciling-the-virtual-interrupt-state-to-the-epilogue-logic">Reconciling the virtual interrupt state to the epilogue logic</a></li>
    <li><a href="#mapping-descriptor-less-per-cpu-irqs-to-pipelined-irq-numbers">Mapping descriptor-less per-CPU IRQs to pipelined IRQ numbers</a></li>
    <li><a href="#dealing-with-ipis">Dealing with IPIs</a>
      <ul>
        <li></li>
        <li><a href="#short-of-ipi-vectors-multiplex">Short of IPI vectors? Multiplex!</a></li>
      </ul>
    </li>
  </ul>
</nav>
              </div>
            </div>
        </div>
        <div id="head-tags">
        </div>
        <main id="body-inner">
          <h1>Биты, зависящие от архитектуры</h1>

<h2 id="irq-state-virtualization">Виртуализация маски прерывания</h2>
<p>Специфичный для архитектуры код, который управляет флагом прерывания в регистре
состояния процессора в <em><code>arch/&lt;your-arch&gt;/include/asm/irqflags.h</code></em> следует
разделить между реальным и виртуальным управлением прерываниями. Реальные
операции управления прерываниями унаследованы от реализации внутриполосного ядра.
Виртуальные должны быть построены на услугах, предоставляемых
<a href="https://the-going.github.io/evlproject/ru/dovetail/porting/irqflow/">ядром конвейера прерываний</a>.</p>
<ul>
<li>во-первых, исходные помощники <em><code>arch\_local_*</code></em> следует переименовать в
помощники <em><code>native_*</code></em> , влияющие на состояние аппаратного прерывания в ЦП.
Это соглашение об именовании накладывается на код архитектуры универсальными
помощниками в <em><code>include/asm-generic/irq\_pipeline.h</code></em>.</li>
</ul>
<blockquote>
<p>Пример: представляем <em>собственные</em> средства доступа к состояниям прерывания
для архитектуры ARM</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#ef6155">--- a/arch/arm/include/asm/irqflags.h
</span><span style="color:#ef6155"></span><span style="color:#48b685">+++ b/arch/arm/include/asm/irqflags.h
</span><span style="color:#48b685"></span> #if __LINUX_ARM_ARCH__ &gt;= 6

 #define arch_local_irq_save arch_local_irq_save
<span style="color:#ef6155">-static inline unsigned long arch_local_irq_save(void)
</span><span style="color:#ef6155"></span><span style="color:#48b685">+static inline unsigned long native_irq_save(void)
</span><span style="color:#48b685"></span> {
 	unsigned long flags;

 	asm volatile(
<span style="color:#ef6155">-		&#34;	mrs	%0, &#34; IRQMASK_REG_NAME_R &#34;	@ arch_local_irq_save\n&#34;
</span><span style="color:#ef6155"></span><span style="color:#48b685">+		&#34;	mrs	%0, &#34; IRQMASK_REG_NAME_R &#34;	@ native_irq_save\n&#34;
</span><span style="color:#48b685"></span> 		&#34;	cpsid	i&#34;
 		: &#34;=r&#34; (flags) : : &#34;memory&#34;, &#34;cc&#34;);
 	return flags;
 }

 #define arch_local_irq_enable arch_local_irq_enable
<span style="color:#ef6155">-static inline void arch_local_irq_enable(void)
</span><span style="color:#ef6155"></span><span style="color:#48b685">+static inline void native_irq_enable(void)
</span><span style="color:#48b685"></span> {
 	asm volatile(
<span style="color:#ef6155">-		&#34;	cpsie i			@ arch_local_irq_enable&#34;
</span><span style="color:#ef6155"></span><span style="color:#48b685">+		&#34;	cpsie i			@ native_irq_enable&#34;
</span><span style="color:#48b685"></span> 		:
 		:
 		: &#34;memory&#34;, &#34;cc&#34;);
 }

 #define arch_local_irq_disable arch_local_irq_disable
<span style="color:#ef6155">-static inline void arch_local_irq_disable(void)
</span><span style="color:#ef6155"></span><span style="color:#48b685">+static inline void native_irq_disable(void)
</span><span style="color:#48b685"></span> {
 	asm volatile(
<span style="color:#ef6155">-		&#34;	cpsid i			@ arch_local_irq_disable&#34;
</span><span style="color:#ef6155"></span><span style="color:#48b685">+		&#34;	cpsid i			@ native_irq_disable&#34;
</span><span style="color:#48b685"></span> 		:
 		:
 		: &#34;memory&#34;, &#34;cc&#34;);
<span style="color:#5bc4bf;font-weight:bold">@@ -69,12 +76,12 @@ static inline void arch_local_irq_disable(void)
</span><span style="color:#5bc4bf;font-weight:bold"></span>  * Save the current interrupt enable state &amp; disable IRQs
  */
 #define arch_local_irq_save arch_local_irq_save
<span style="color:#ef6155">-static inline unsigned long arch_local_irq_save(void)
</span><span style="color:#ef6155"></span><span style="color:#48b685">+static inline unsigned long native_irq_save(void)
</span><span style="color:#48b685"></span> {
 	unsigned long flags, temp;

 	asm volatile(
<span style="color:#ef6155">-		&#34;	mrs	%0, cpsr	@ arch_local_irq_save\n&#34;
</span><span style="color:#ef6155"></span><span style="color:#48b685">+		&#34;	mrs	%0, cpsr	@ native_irq_save\n&#34;
</span><span style="color:#48b685"></span> 		&#34;	orr	%1, %0, #128\n&#34;
 		&#34;	msr	cpsr_c, %1&#34;
 		: &#34;=r&#34; (flags), &#34;=r&#34; (temp)
<span style="color:#5bc4bf;font-weight:bold">@@ -87,11 +94,11 @@ static inline unsigned long arch_local_irq_save(void)
</span><span style="color:#5bc4bf;font-weight:bold"></span>  * Enable IRQs
  */
 #define arch_local_irq_enable arch_local_irq_enable
<span style="color:#ef6155">-static inline void arch_local_irq_enable(void)
</span><span style="color:#ef6155"></span><span style="color:#48b685">+static inline void native_irq_enable(void)
</span><span style="color:#48b685"></span> {
 	unsigned long temp;
 	asm volatile(
<span style="color:#ef6155">-		&#34;	mrs	%0, cpsr	@ arch_local_irq_enable\n&#34;
</span><span style="color:#ef6155"></span><span style="color:#48b685">+		&#34;	mrs	%0, cpsr	@ native_irq_enable\n&#34;
</span><span style="color:#48b685"></span> 		&#34;	bic	%0, %0, #128\n&#34;
 		&#34;	msr	cpsr_c, %0&#34;
 		: &#34;=r&#34; (temp)
<span style="color:#5bc4bf;font-weight:bold">@@ -103,11 +110,11 @@ static inline void arch_local_irq_enable(void)
</span><span style="color:#5bc4bf;font-weight:bold"></span>  * Disable IRQs
  */
 #define arch_local_irq_disable arch_local_irq_disable
<span style="color:#ef6155">-static inline void arch_local_irq_disable(void)
</span><span style="color:#ef6155"></span><span style="color:#48b685">+static inline void native_irq_disable(void)
</span><span style="color:#48b685"></span> {
 	unsigned long temp;
 	asm volatile(
<span style="color:#ef6155">-		&#34;	mrs	%0, cpsr	@ arch_local_irq_disable\n&#34;
</span><span style="color:#ef6155"></span><span style="color:#48b685">+		&#34;	mrs	%0, cpsr	@ native_irq_disable\n&#34;
</span><span style="color:#48b685"></span> 		&#34;	orr	%0, %0, #128\n&#34;
 		&#34;	msr	cpsr_c, %0&#34;
 		: &#34;=r&#34; (temp)
<span style="color:#5bc4bf;font-weight:bold">@@ -153,11 +160,11 @@ static inline void arch_local_irq_disable(void)
</span><span style="color:#5bc4bf;font-weight:bold"></span>  * Save the current interrupt enable state.
  */
 #define arch_local_save_flags arch_local_save_flags
<span style="color:#ef6155">-static inline unsigned long arch_local_save_flags(void)
</span><span style="color:#ef6155"></span><span style="color:#48b685">+static inline unsigned long native_save_flags(void)
</span><span style="color:#48b685"></span> {
 	unsigned long flags;
 	asm volatile(
<span style="color:#ef6155">-		&#34;	mrs	%0, &#34; IRQMASK_REG_NAME_R &#34;	@ local_save_flags&#34;
</span><span style="color:#ef6155"></span><span style="color:#48b685">+		&#34;	mrs	%0, &#34; IRQMASK_REG_NAME_R &#34;	@ native_save_flags&#34;
</span><span style="color:#48b685"></span> 		: &#34;=r&#34; (flags) : : &#34;memory&#34;, &#34;cc&#34;);
 	return flags;
 }
<span style="color:#5bc4bf;font-weight:bold">@@ -166,21 +173,28 @@ static inline unsigned long arch_local_save_flags(void)
</span><span style="color:#5bc4bf;font-weight:bold"></span>  * restore saved IRQ &amp; FIQ state
  */
 #define arch_local_irq_restore arch_local_irq_restore
<span style="color:#ef6155">-static inline void arch_local_irq_restore(unsigned long flags)
</span><span style="color:#ef6155"></span><span style="color:#48b685">+static inline void native_irq_restore(unsigned long flags)
</span><span style="color:#48b685"></span> {
 	asm volatile(
<span style="color:#ef6155">-		&#34;	msr	&#34; IRQMASK_REG_NAME_W &#34;, %0	@ local_irq_restore&#34;
</span><span style="color:#ef6155"></span><span style="color:#48b685">+		&#34;	msr	&#34; IRQMASK_REG_NAME_W &#34;, %0	@ native_irq_restore&#34;
</span><span style="color:#48b685"></span> 		:
 		: &#34;r&#34; (flags)
 		: &#34;memory&#34;, &#34;cc&#34;);
 }

 #define arch_irqs_disabled_flags arch_irqs_disabled_flags
<span style="color:#ef6155">-static inline int arch_irqs_disabled_flags(unsigned long flags)
</span><span style="color:#ef6155"></span><span style="color:#48b685">+static inline int native_irqs_disabled_flags(unsigned long flags)
</span><span style="color:#48b685"></span> {
 	return flags &amp; IRQMASK_I_BIT;
 }

<span style="color:#48b685">+static inline bool native_irqs_disabled(void)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	unsigned long flags = native_save_flags();
</span><span style="color:#48b685">+	return native_irqs_disabled_flags(flags);
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+#include &lt;asm/irq_pipeline.h&gt;
</span><span style="color:#48b685"></span> #include &lt;asm-generic/irqflags.h&gt;

 #endif /* ifdef __KERNEL__ */
</code></pre></div><ul>
<li>в финале, должен быть предоставлен новый набор помощников <em><code>arch\_local\_*</code></em>,
влияющих на флаг отключения виртуального прерывания, реализованный ядром
конвейера для управления защитой внутриполосной стадии от прерываний.
Рекомендуется реализовать этот набор в отдельном файле, доступном для
включения из <em><code>&lt;asm/irq_pipeline.h&gt;</code></em>.</li>
</ul>
<blockquote>
<p>Пример: предоставление средств доступа к состоянию виртуального прерывания для
архитектуры ARM</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#ef6155">--- /dev/null
</span><span style="color:#ef6155"></span><span style="color:#48b685">+++ b/arch/arm/include/asm/irq_pipeline.h
</span><span style="color:#48b685"></span><span style="color:#5bc4bf;font-weight:bold">@@ -0,0 +1,138 @@
</span><span style="color:#5bc4bf;font-weight:bold"></span><span style="color:#48b685">+#ifndef _ASM_ARM_IRQ_PIPELINE_H
</span><span style="color:#48b685">+#define _ASM_ARM_IRQ_PIPELINE_H
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+#include &lt;asm-generic/irq_pipeline.h&gt;
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+#ifdef CONFIG_IRQ_PIPELINE
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline notrace unsigned long arch_local_irq_save(void)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	int stalled = inband_irq_save();
</span><span style="color:#48b685">+	barrier();
</span><span style="color:#48b685">+	return arch_irqs_virtual_to_native_flags(stalled);
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline notrace void arch_local_irq_enable(void)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	barrier();
</span><span style="color:#48b685">+	inband_irq_enable();
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline notrace void arch_local_irq_disable(void)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	inband_irq_disable();
</span><span style="color:#48b685">+	barrier();
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline notrace unsigned long arch_local_save_flags(void)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	int stalled = inband_irqs_disabled();
</span><span style="color:#48b685">+	barrier();
</span><span style="color:#48b685">+	return arch_irqs_virtual_to_native_flags(stalled);
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline int arch_irqs_disabled_flags(unsigned long flags)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	return native_irqs_disabled_flags(flags);
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline notrace void arch_local_irq_restore(unsigned long flags)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	if (!arch_irqs_disabled_flags(flags))
</span><span style="color:#48b685">+		__inband_irq_enable();
</span><span style="color:#48b685">+	barrier();
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+#else /* !CONFIG_IRQ_PIPELINE */
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline unsigned long arch_local_irq_save(void)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	return native_irq_save();
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline void arch_local_irq_enable(void)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	native_irq_enable();
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline void arch_local_irq_disable(void)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	native_irq_disable();
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline unsigned long arch_local_save_flags(void)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	return native_save_flags();
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline void arch_local_irq_restore(unsigned long flags)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	native_irq_restore(flags);
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline int arch_irqs_disabled_flags(unsigned long flags)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	return native_irqs_disabled_flags(flags);
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+#endif /* !CONFIG_IRQ_PIPELINE */
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+#endif /* _ASM_ARM_IRQ_PIPELINE_H */
</span></code></pre></div>
<div class="notices note">
    <div class="label">Заметка</div><p>Этот новый файл должен включать <em>&lt;asm-generic/irq_pipeline.h&gt;</em> заранее, чтобы
получить доступ к объявлениям конвейера, в которых он нуждается. Это включение
должно быть безусловным, даже если ядро построено с отключенной конфигурацией
CONFIG_IRQ_PIPELINE.</p>

</div>
<h3 id="обеспечение-поддержки-объединенных-состояний-прерывания">Обеспечение поддержки объединенных состояний прерывания</h3>
<p>Реализация конвейера общих прерываний требует, чтобы код поддержки на уровне
архитектуры обеспечивал пару помощников, направленных на преобразование
<a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/#virtual-i-flag">отключение флага виртуального прерывания</a>
в бит прерывания в регистре состояния процессора (например, PSR_I_BIT для ARM)
и наоборот. Эти помощники используются для создания комбинированных слов
состояний, объединяющих виртуальные и реальные состояния прерывания.</p>
<ul>
<li>
<p><code>arch_irqs_virtual_to_native_flags(int stalled)</code> должно возвращать длинное
слово, переназначающее логическое значение @stalled в позию бита прерывания
процессора в регистре состояния. Все остальные биты должны быть очищены.</p>
<ul>
<li>На ARM это может быть выражено как <code>(stalled ? PSR_I_BIT : 0)</code>.</li>
<li>на x86 это было бы скорее <code>(stalled ? 0 : X86_EFLAGS_IF)</code>.</li>
</ul>
</li>
<li>
<p><code>arch_irqs_native_to_virtual_flags(unsigned long flags)</code> необходимо вернуть
длинное слово, переназначающее бит прерывания процессора в @flags в
произвольную позицию бита, выбранную так, чтобы не конфликтовать с первым.
Другими словами, бит состояния прерывания процессора, полученный в @flags,
должен быть смещен в свободное положение, произвольно выбранное в возвращаемом
значении. Все остальные биты должны быть очищены.</p>
<ul>
<li>
<p>На ARM, используя позицию бита 31 для отражения виртуального состояния,
это выражается как <code>(hard_irqs_disabled_flags(flags) ? (1 &lt;&lt; 31) : 0)</code>.</p>
</li>
<li>
<p>В любой другой архитектуре реализация была бы аналогичной, используя любую
доступную позицию бита, которая не конфликтовала бы с позицией бита
прерывания процессора.</p>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#ef6155">--- a/arch/arm/include/asm/irqflags.h
</span><span style="color:#ef6155"></span><span style="color:#48b685">+++ b/arch/arm/include/asm/irqflags.h
</span><span style="color:#48b685"></span>/*
 * CPU interrupt mask handling.
 */
#ifdef CONFIG_CPU_V7M
 #define IRQMASK_REG_NAME_R &#34;primask&#34;
 #define IRQMASK_REG_NAME_W &#34;primask&#34;
 #define IRQMASK_I_BIT	1
<span style="color:#48b685">+#define IRQMASK_I_POS	0
</span><span style="color:#48b685"></span> #else
 #define IRQMASK_REG_NAME_R &#34;cpsr&#34;
 #define IRQMASK_REG_NAME_W &#34;cpsr_c&#34;
 #define IRQMASK_I_BIT	PSR_I_BIT
<span style="color:#48b685">+#define IRQMASK_I_POS	7
</span><span style="color:#48b685"></span> #endif
<span style="color:#48b685">+#define IRQMASK_i_POS	31
</span></code></pre></div>
<div class="notices tip">
    <div class="label">Совет</div><p><code>IRQMASK_i_POS</code> (обратите внимание на прописную &lsquo;i&rsquo;) это позиция свободного бита
в комбинированном слове, где порт ARM сохраняет исходное состояние прерывания
процессора в комбинированном слове. Эта позиция не может конфликтовать с
<code>IRQMASK_I_POS</code>,  который является псевдонимом <code>PSR_I_BIT</code>
(разрядная позиция 0 или 7).</p>

</div>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#ef6155">--- /dev/null
</span><span style="color:#ef6155"></span><span style="color:#48b685">+++ b/arch/arm/include/asm/irq_pipeline.h
</span><span style="color:#48b685">+
</span><span style="color:#48b685">+static inline notrace
</span><span style="color:#48b685">+unsigned long arch_irqs_virtual_to_native_flags(int stalled)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	return (!!stalled) &lt;&lt; IRQMASK_I_POS;
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+static inline notrace
</span><span style="color:#48b685">+unsigned long arch_irqs_native_to_virtual_flags(unsigned long flags)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	return (!!hard_irqs_disabled_flags(flags)) &lt;&lt; IRQMASK_i_POS;
</span><span style="color:#48b685">+}
</span></code></pre></div>
<div class="notices info">
    <div class="label">Информация</div><p>Как только все эти изменения будут внесены, общие помощники из &lt;linux/irqflags.h&gt;,
такие как <code>local_irq_disable()</code> и <code>local_irq_enable()</code>, фактически ссылаются на
<strong>виртуальную</strong> схему защиты, когда прерывания передаются по конвейеру, что в
конечном итоге позволяет реализовать
<a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/#irq-deferral">отсрочку прерывания</a>
для защищенного внутриполосного кода, выполняемого на внутриполосной стадии.</p>

</div>
<h2 id="arch-irq-handling">Адаптация кода ассемблера к конвейерной обработке IRQ</h2>
<h3 id="arch-irq-entry">Запись прерывания</h3>
<p>Поскольку общая обработка IRQ является
<a href="https://the-going.github.io/evlproject/ru/dovetail/porting/prerequisites/">обязательным требованием</a>
для поддержки Dovetail, низкоуровневый обработчик прерываний, находящийся в части
кода ассемблера архитектуры, все еще может доставлять все события прерывания в
исходный обработчик написанный на C, предоставляемый драйвером irqchip.
Этот обработчик, в свою очередь, должен вызывать:</p>
<ul>
<li>
<p><code>handle_domain_irq()</code> для всех IRQ родительского устройства</p>
</li>
<li>
<p><code>generic_handle_irq()</code> для каскадных IRQ-запросов устройств (декодированных из
родительского обработчика)</p>
</li>
</ul>
<p>Для этих подпрограмм начальная задача вставки прерывания в начале конвейера
обрабатывается непосредственно с уровня <em>genirq</em>, к которому они принадлежат.
Это означает, что обычно не так много нужно сделать, кроме как быстро проверить
реализацию родительского обработчика IRQ в соответствующем драйвере <em>irqchip</em>,
тщательно применяя <a href="https://the-going.github.io/evlproject/ru/dovetail/rulesofthumb/">эмпирические правила</a>.</p>

<div class="notices tip">
    <div class="label">Совет</div><p>На какой-нибудь платформе ARM, оснащенной довольно распространенным контроллером GIC,
это означало бы, например, проверку функции <code>gic_handle_irq()</code>.</p>

</div>
<ul>
<li>специфичный для архитектуры <code>handle_IPI()</code> или эквивалент для специальных
межпроцессорных прерываний</li>
</ul>
<p>IPI должны быть обработаны
<a href="https://the-going.github.io/evlproject/ru/dovetail/porting/arch/#dealing-with-ipis">конкретными изменениями</a>,
внесенными портом, о котором мы расскажем позже.</p>
<h3 id="arch-irq-exit">Прерывание выхода</h3>
<p>Когда конвейерная обработка прерываний отключена, ядро обычно запускает эпилог
после обработки каждого события прерывания или исключения. Если событие произошло,
когда процессор выполнял какой-либо код ядра, эпилог проверит потенциальную
возможность перепланирования в случае, если включен параметр <code>CONFIG_PREEMPT</code>.
Если задача пользовательского пространства была вытеснена событием, будут
проверены дополнительные условия, такие как ожидание доставки сигнала для
этой задачи.</p>
<p>Поскольку прерывания практически маскируются только для внутриполосного кода,
когда включена конвейерная обработка, ЦП все равно может принимать запросы IRQ
и передавать их ассемблерным обработчикам низкого уровня, чтобы они могли
входить в конвейер прерываний.</p>
<blockquote>
<p>Запуск обычного эпилога после IRQ допустим только в том случае, если ядро
фактически принимало прерывания, когда произошло событие (т.е. Флаг отключения
виртуального прерывания был снят), и запускался внутриполосный код.</p>
</blockquote>
<p>Во всех остальных случаях, за исключением  конвейера прерываний ядра, остальная
часть ядра не ожидает, что эти IRQ когда-либо произойдут в первую очередь.
Поэтому запуск эпилога в таких обстоятельствах противоречил бы логике ядра.
Кроме того, низкоуровневые обработчики должны быть осведомлены о том, что они
могут получить событие в таких условиях.</p>
<p>Например, исходный код ARM для обработки IRQ, который вытеснил контекст ядра,
будет выглядеть следующим образом:</p>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-S" data-lang="S">__irq_svc<span style="color:#5bc4bf">:</span>
	svc_entry
	irq_handler

<span style="color:#8d8687">#ifdef CONFIG_PREEMPT</span>
	ldr	r8, [tsk, <span style="color:#8d8687">#TI_PREEMPT]		@ get preempt count</span>
	ldr	r0, [tsk, <span style="color:#8d8687">#TI_FLAGS]		@ get flags</span>
	teq	r8, <span style="color:#8d8687">#0				@ if preempt count != 0</span>
	movne	r0, <span style="color:#8d8687">#0				@ force flags to 0</span>
	tst	r0, <span style="color:#8d8687">#_TIF_NEED_RESCHED</span>
	blne	svc_preempt
<span style="color:#8d8687">#endif</span>
</code></pre></div><p>Чтобы правильно обрабатывать прерывания в конвейерной модели доставки, мы должны
определить, было ли внутриполосное ядро готово принять такое событие, действуя
на него соответствующим образом. С этой целью порт ARM вместо этого передает
событие в подпрограмму трамплина (<code>handle_arch_irq_pipelined()</code>), ожидая по
возвращении решения о том, должен ли код эпилога выполняться следующим. На рисунке
ниже это решение возвращается вызывающему в виде логического статуса,
отличного от нуля, что означает, что мы можем запустить эпилог,
в противном случае ноль.</p>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-patch" data-lang="patch"><span style="color:#ef6155">--- a/arch/arm/kernel/entry-armv.S
</span><span style="color:#ef6155"></span><span style="color:#48b685">+++ b/arch/arm/kernel/entry-armv.S
</span><span style="color:#48b685"></span> 	.macro	irq_handler
 #ifdef CONFIG_MULTI_IRQ_HANDLER
<span style="color:#ef6155">-	ldr	r1, =handle_arch_irq
</span><span style="color:#ef6155"></span> 	mov	r0, sp
 	badr	lr, 9997f
<span style="color:#48b685">+#ifdef CONFIG_IRQ_PIPELINE
</span><span style="color:#48b685">+	ldr	r1, =handle_arch_irq_pipelined
</span><span style="color:#48b685">+	mov	pc, r1
</span><span style="color:#48b685">+#else
</span><span style="color:#48b685">+	ldr	r1, =handle_arch_irq
</span><span style="color:#48b685"></span> 	ldr	pc, [r1]
<span style="color:#ef6155">-#else
</span><span style="color:#ef6155"></span><span style="color:#48b685">+#endif
</span><span style="color:#48b685">+#elif CONFIG_IRQ_PIPELINE
</span><span style="color:#48b685">+#error &#34;Legacy IRQ handling not pipelined&#34;
</span><span style="color:#48b685">+#else
</span><span style="color:#48b685"></span> 	arch_irq_handler_default
 #endif
 9997:
 	.endm
</code></pre></div><p>Процедура трамплина, добавленная в исходный код, сначала доставляет прерывание
определяемому машиной обработчику, а затем сообщает вызывающему, может ли
обычный эпилог выполняться для такого события.</p>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-patch" data-lang="patch"><span style="color:#ef6155">--- a/arch/arm/kernel/irq.c
</span><span style="color:#ef6155"></span><span style="color:#48b685">+++ b/arch/arm/kernel/irq.c
</span><span style="color:#48b685"></span><span style="color:#5bc4bf;font-weight:bold">@@ -112,6 +112,15 @@ void __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
</span><span style="color:#5bc4bf;font-weight:bold"></span> }
 #endif

<span style="color:#48b685">+#ifdef CONFIG_IRQ_PIPELINE
</span><span style="color:#48b685">+asmlinkage int __exception_irq_entry
</span><span style="color:#48b685">+handle_arch_irq_pipelined(struct pt_regs *regs)
</span><span style="color:#48b685">+{
</span><span style="color:#48b685">+	handle_arch_irq(regs);
</span><span style="color:#48b685">+	return running_inband() &amp;&amp; !irqs_disabled();
</span><span style="color:#48b685">+}
</span><span style="color:#48b685">+#endif
</span><span style="color:#48b685">+
</span></code></pre></div><p>Eventually, the low-level assembly handler receiving the interrupt
event is adapted, in order to carry out the earlier decision by
<code>handle_arch_irq_pipelined()</code>, skipping the epilogue code if required
to.</p>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
 __irq_svc:
 	svc_entry
 	irq_handler
+#ifdef CONFIG_IRQ_PIPELINE
+	tst	r0, r0
+	beq	1f
+#endif

 #ifdef CONFIG_PREEMPT
 	ldr	r8, [tsk, #TI_PREEMPT]		@ get preempt count
 	blne	svc_preempt
 #endif

+1:
 	svc_exit r5, irq = 1			@ return from exception
</code></pre></div>
<div class="notices warning">
    <div class="label">Внимание</div><p>Taking the fast exit path when applicable is critical to the stability of the
target system to prevent <a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/#no-inband-reentry">invalid re-entry</a> of the in-band kernel
code.</p>

</div>
<h3 id="fault-exit">Fault exit</h3>
<p>Similarly to the interrupt exit case, the low-level fault handling
code must skip the epilogue code when the fault was taken over an
out-of-band context. Upon fault, the current interrupt state is not
considered for determining whether we should run the epilogue, since
a fault may occur independently of such state.</p>
<blockquote>
<p>Running the regular epilogue after a fault is valid only if that
fault was triggered by some in-band code, excluding any fault raised
by out-of-band code.</p>
</blockquote>
<p>For instance, the original ARM code for returning from an exception
event would be modified as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
@@ -754,7 +772,7 @@ ENTRY(ret_from_exception)
  UNWIND(.cantunwind	)
 	get_thread_info tsk
 	mov	why, #0
-	b	ret_to_user
+	ret_to_user_pipelined r1
  UNWIND(.fnend		)
</code></pre></div><p>With the implementation of <code>ret_to_user_pipelined</code> checking for the
current stage, skipping the epilogue if the faulting code was running
over an out-of-band context:</p>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">--- a/arch/arm/kernel/entry-header.S
+++ b/arch/arm/kernel/entry-header.S
+/*
+ * Branch to the exception epilogue, skipping the in-band work
+ * if running over the oob interrupt stage.
+ */
+	.macro ret_to_user_pipelined, tmp
+#ifdef CONFIG_IRQ_PIPELINE
+	ldr	\tmp, [tsk, #TI_LOCAL_FLAGS]
+	tst	\tmp, #_TLF_OOB
+	bne	fast_ret_to_user
+#endif
+	b	ret_to_user
+	.endm
+
</code></pre></div><p><code>_TLF_OOB</code> is a local <code>thread_info</code> flag denoting a current task
running out-of-band code over the out-of-band stage. If set, the
epilogue must be skipped.</p>
<h2 id="reconciling-the-virtual-interrupt-state-to-the-epilogue-logic">Reconciling the virtual interrupt state to the epilogue logic</h2>
<p>A tricky issue to address when pipelining interrupts is about making
sure that the logic from the epilogue routine
(e.g. <em>do_work_pending()</em>, <em>do_notify_resume()</em>) actually runs in
the expected <a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/#virtual-i-flag">(virtual) interrupt state</a> for the in-band stage.</p>
<p>Reconciling the virtual interrupt state to the in-band logic dealing
with interrupts is required because in a pipelined interrupt model,
the virtual interrupt state of the in-band stage does not necessarily
reflect the CPU&rsquo;s interrupt state on entry to the early assembly code
handling the IRQ events. Typically, a CPU would always automatically
disable interrupts hardware-wise when taking an IRQ, which may
contradict the software-managed virtual state until both are
eventually reconciled.</p>
<p>Those rules of thumb should be kept in mind when adapting the epilogue
routine to interrupt pipelining:</p>
<ul>
<li>
<p>most often, such routine is supposed to be entered with (hard)
interrupts off when called from the assembly code which handles
kernel entry/exit transitions (e.g. arch/arm/kernel/entry-common.S).
Therefore, this routine may have to reconcile the virtual interrupt
state with such expectation, since according to the <a href="https://the-going.github.io/evlproject/ru/dovetail/porting/arch/#arch-irq-exit">interrupt exit
rules</a> we
discussed earlier, such state has to be originally enabled (i.e. the
in-band stall bit is clear) for the epilogue code to run in the
first place.</p>
</li>
<li>
<p>conversely, we must keep the hard interrupt state consistent upon
return from the epilogue code with the one received on
entry. Typically, hard interrupts must be disabled before leaving
this code if we entered it that way.</p>
</li>
<li>
<p>calling <em>schedule()</em> should be done with IRQs enabled in the CPU, in
order to minimize latency for the out-of-band stage
(i.e. <code>hard_irqs_disabled()</code> should return <em>false</em> before the call).</p>
</li>
<li>
<p>generally speaking, while we may need the in-band stage to be
stalled when the in-band kernel code expects this, we still want
most of the epilogue code to run with <a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/interrupt_protection/#hard-irq-protection">hard interrupts
enabled</a>
to shorten the interrupt latency for the out-of-band stage, where
the autonomous core lives.</p>
</li>
</ul>
<blockquote>
<p>Reconciling the interrupt state in ARM64 epilogue</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"> #include &lt;linux/errno.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/signal.h&gt;
+#include &lt;linux/irq_pipeline.h&gt;
 #include &lt;linux/personality.h&gt;
 #include &lt;linux/freezer.h&gt;
 #include &lt;linux/stddef.h&gt;
@@ -915,24 +916,34 @@ static void do_signal(struct pt_regs *regs)
 asmlinkage void do_notify_resume(struct pt_regs *regs,
 				 unsigned long thread_flags)
 {
+	WARN_ON_ONCE(irq_pipeline_debug() &amp;&amp;
+		(irqs_disabled() || running_oob()));
+
 	/*
 	 * The assembly code enters us with IRQs off, but it hasn&#39;t
 	 * informed the tracing code of that for efficiency reasons.
 	 * Update the trace code with the current status.
 	 */
-	trace_hardirqs_off();
+	if (!irqs_pipelined())
+		trace_hardirqs_off();

 	do {
+		if (irqs_pipelined())
+			local_irq_disable();
+
 		/* Check valid user FS if needed */
 		addr_limit_user_check();

 		if (thread_flags &amp; _TIF_NEED_RESCHED) {
 			/* Unmask Debug and SError for the next task */
-			local_daif_restore(DAIF_PROCCTX_NOIRQ);
+			local_daif_restore(irqs_pipelined() ?
+					DAIF_PROCCTX : DAIF_PROCCTX_NOIRQ);

 			schedule();
 		} else {
 			local_daif_restore(DAIF_PROCCTX);
+			if (irqs_pipelined())
+				local_irq_enable();

 			if (thread_flags &amp; _TIF_UPROBE)
 				uprobe_notify_resume(regs);
@@ -950,9 +961,17 @@ asmlinkage void do_notify_resume(struct pt_regs *regs,
 				fpsimd_restore_current_state();
 		}

+		/*
+		 * CAUTION: we may have restored the fpsimd state for
+		 * current with no other opportunity to check for
+		 * _TIF_FOREIGN_FPSTATE until we are back running on
+		 * el0, so we must not take any interrupt until then,
+		 * otherwise we may end up resuming with some OOB
+		 * thread&#39;s fpsimd state.
+		 */
 		local_daif_mask();
 		thread_flags = READ_ONCE(current_thread_info()-&gt;flags);
-	} while (thread_flags &amp; _TIF_WORK_MASK);
+	} while (inband_irq_pending() || (thread_flags &amp; _TIF_WORK_MASK));
 }
</code></pre></div><h2 id="mapping-descriptor-less-per-cpu-irqs-to-pipelined-irq-numbers">Mapping descriptor-less per-CPU IRQs to pipelined IRQ numbers</h2>
<p>Some architecture ports may not assign interrupt descriptors
(i.e. <code>struct irq_desc</code>) to per-CPU interrupts. Instead, those per-CPU
events are immediately handled by arch-specific code, instead of being
channeled through the common generic IRQ layer for delivery to their
respective handler. With Dovetail, we do generally need all interrupts
to have a valid interrupt descriptor, including per-CPU events, so
that we can request them to be handled on the out-of-band stage using
the <a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/irq_handling/">generic IRQ API</a>, like we would request any regular device interrupt.</p>
<p>The easiest way to achieve this mapping is to create a new synthetic
interrupt domain for IPIs, which are in essence per-CPU
events. Therefore, the flow handler for interrupts from this domain
should be <code>handle_synthetic_irq()</code>.</p>
<p>Prior to kernel v5.10-rc6, all Dovetail ports (x86, ARM and arm64)
required a synthetic interrupt domain for the purpose of mapping
descriptor-less per-CPU interrupts. Since v5.10-rc6 and the
introduction of a native mapping of each IPI to a common interrupt
descriptor for ARM and arm64, only Dovetail/x86 still needs to
implement a specific interrupt domain in order to map the APIC system
interrupts.</p>
<h2 id="dealing-with-ipis">Dealing with IPIs</h2>
<p>Although the pipeline does not directly use inter-processor interrupts
internally, it provides a simple API to autonomous cores for
implementing <a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/pipeline_inject/#oob-ipi">IPI-based messaging</a> between
CPUs.  This feature requires the Dovetail port to implement a few bits
of architecture-specific code. The arch-specific Dovetail
implementation must provide support for two operations:</p>
<ul>
<li>
<p>sending the additional IPI signals defined by the <a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/pipeline_inject/#oob-ipi">Dovetail API</a>
using the mechanism available from your hardware for inter-processor
messaging, upon request from <code>irq_send_oob_ipi()</code>.</p>
</li>
<li>
<p><a href="https://the-going.github.io/evlproject/ru/dovetail/porting/irqflow/#arch-do-irq">dispatching deferred IPIs</a> to their
respective in-band handler upon request from the Dovetail core.</p>
</li>
</ul>
<h4 id="prior-to-kernel-v510-rc6">Prior to kernel v5.10-rc6</h4>
<p>Until v5.10-rc6, the ARM and arm64 implementations would register IPIs
from a synthetic IPI interrupt domain, from IRQ2048 (<code>OOB_IPI_BASE</code>)
and on.</p>
<p>The arch-specific implementation of <code>handle_IPI()</code> in a
Dovetail-enabled kernel should generate IRQs from this IPI domain each
time an IPI event is received from the hardware, by calling
<a href="https://the-going.github.io/evlproject/ru/dovetail/porting/irqflow/#genirq-flow">generic_pipeline_irq()</a>.</p>
<blockquote>
<p>IPI domain for ARM</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">static struct irq_domain *sipic_domain;

static void sipic_irq_noop(struct irq_data *data) { }

static unsigned int sipic_irq_noop_ret(struct irq_data *data)
{
	return 0;
}

static struct irq_chip sipic_chip = {
	.name		= &#34;SIPIC&#34;,
	.irq_startup	= sipic_irq_noop_ret,
	.irq_shutdown	= sipic_irq_noop,
	.irq_enable	= sipic_irq_noop,
	.irq_disable	= sipic_irq_noop,
	.irq_ack	= sipic_irq_noop,
	.irq_mask	= sipic_irq_noop,
	.irq_unmask	= sipic_irq_noop,
	.flags		= IRQCHIP_PIPELINE_SAFE | IRQCHIP_SKIP_SET_WAKE,
};

static int sipic_irq_map(struct irq_domain *d, unsigned int irq,
			irq_hw_number_t hwirq)
{
	irq_set_percpu_devid(irq);
	irq_set_chip_and_handler(irq, &amp;sipic_chip, handle_synthetic_irq);

	return 0;
}

static struct irq_domain_ops sipic_domain_ops = {
	.map	= sipic_irq_map,
};

static void create_ipi_domain(void)
{
	/*
	 * Create an IRQ domain for mapping all IPIs (in-band and
	 * out-of-band), with fixed sirq numbers starting from
	 * OOB_IPI_BASE. The sirqs obtained can be injected into the
	 * pipeline upon IPI receipt like other interrupts.
	 */
	sipic_domain = irq_domain_add_simple(NULL, NR_IPI + OOB_NR_IPI,
					     OOB_IPI_BASE,
					     &amp;sipic_domain_ops, NULL);
}

void __init arch_irq_pipeline_init(void)
{
#ifdef CONFIG_SMP
	create_ipi_domain();
#endif
}
</code></pre></div>
<div class="notices note">
    <div class="label">Заметка</div><p>Initializing the IPI domain should be done from
the <code>arch_irq_pipeline_init()</code> handler, which Dovetail calls while
setting up the interrupt pipelining machinery early at kernel boot.</p>

</div>
<h4 id="since-kernel-v510-rc6">Since kernel v5.10-rc6</h4>
<p>Since v5.10-rc6, the ARM and arm64 implementations assign a common
interrupt descriptor to each IPI, therefore we need no synthetic
interrupt domain for that purpose anymore.</p>
<h3 id="short-of-ipi-vectors-multiplex">Short of IPI vectors? Multiplex!</h3>
<p>Your hardware may be limited with respect to the number of distinct
IPI signals available from the interrupt controller. Typically, the
ARM generic interrupt controller (aka <em>GIC</em>) available with the Cortex
CPU series provides 16 distinct IPIs, half of which should be reserved
to the firmware, which leaves only 8 IPIs available to the
kernel. Since all of them are already in use for in-band work in the
mainline implementation, we are short of available IPI vectors for
adding the two additional interrupts we need.  For this reason, the
Dovetail ports for ARM and ARM64 have reshuffled the way IPI signaling
is implemented.</p>
<p>In the upstream kernel implementation, a 1:1 mapping exists between
the logical IPI numbers used by the kernel to refer to inter-processor
messages, and the physical, so-called <em>SGI</em> numbers which stands for
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/CEGIDCIC.html">Software Generated
Interrupts</a>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">IPI Message</th>
<th style="text-align:center">Logical IPI number</th>
<th style="text-align:center">Physical SGI number</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IPI_WAKEUP</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">IPI_TIMER</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">IPI_RESCHEDULE</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">IPI_CALL_FUNC</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">IPI_CPU_STOP</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">IPI_IRQ_WORK</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">IPI_COMPLETION</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">IPI_CPU_BACKTRACE</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<p>After the introduction of IPI multiplexing by Dovetail, all
pre-existing in-band IPIs are now multiplexed over SGI0, which leaves
seven SGIs available for adding out-of-band IPI messages, from which
we only need two in the current implementation.</p>
<h4 id="prior-to-kernel-v510-rc6-1">Prior to kernel v5.10-rc6</h4>
<p>The resulting mapping is as follows:</p>
<table>
<thead>
<tr>
<th style="text-align:center">IPI Message</th>
<th style="text-align:center">Logical IPI number</th>
<th style="text-align:center">Physical SGI number</th>
<th style="text-align:center">Pipelined IRQ number</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IPI_WAKEUP</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2048</td>
</tr>
<tr>
<td style="text-align:center">IPI_TIMER</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2049</td>
</tr>
<tr>
<td style="text-align:center">IPI_RESCHEDULE</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2050</td>
</tr>
<tr>
<td style="text-align:center">IPI_CALL_FUNC</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2051</td>
</tr>
<tr>
<td style="text-align:center">IPI_CPU_STOP</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2052</td>
</tr>
<tr>
<td style="text-align:center">IPI_IRQ_WORK</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2053</td>
</tr>
<tr>
<td style="text-align:center">IPI_COMPLETION</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2054</td>
</tr>
<tr>
<td style="text-align:center">IPI_CPU_BACKTRACE</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2055</td>
</tr>
<tr>
<td style="text-align:center">TIMER_OOB_IPI</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2056</td>
</tr>
<tr>
<td style="text-align:center">RESCHEDULE_OOB_IPI</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2057</td>
</tr>
</tbody>
</table>
<p>The implementation of the IPI multiplexing for ARM takes place in
<code>arch/arm/kernel/smp.c</code>. The logic - as illustrated below - is fairly
straightforward:</p>
<ul>
<li>
<p>on the issuer side, if the IPI we need to send belongs to the
in-band set (<code>ipinr &lt; NR_IPI</code>), log the pending signal into a
per-CPU global bitmask (<code>ipi_messages</code>) then issue SGI0. Otherwise,
issue either SGI1 or SGI2 for signaling the corresponding
out-of-band IPIs directly.</p>
</li>
<li>
<p>upon receipt, if we received SGI0, iterate over the pending in-band
IPIs by reading the per-CPU bitmask (<code>ipi_messages</code>) demultiplexing
the logical IPI numbers as we go before pushing the corresponding
IRQ event to the pipeline entry, see <a href="https://the-going.github.io/evlproject/ru/dovetail/porting/irqflow/#genirq-flow">generic_pipeline_irq()</a>.  If SGI1 or SGI2
are received instead, the incoming event is remapped to either
TIMER_OOB_IPI or RESCHEDULE_OOB_IPI before it is fed into the
pipeline (i.e. IRQ2056 or IRQ2057).</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">static DEFINE_PER_CPU(unsigned long, ipi_messages);

static inline
void send_IPI_message(const struct cpumask *target, unsigned int ipinr)
{
	unsigned int cpu, sgi;

	if (ipinr &lt; NR_IPI) {
		/* regular in-band IPI (multiplexed over SGI0). */
		trace_ipi_raise_rcuidle(target, ipi_types[ipinr]);
		for_each_cpu(cpu, target)
			set_bit(ipinr, &amp;per_cpu(ipi_messages, cpu));
		smp_mb();
		sgi = 0;
	} else	/* out-of-band IPI (SGI1-2). */
		sgi = ipinr - NR_IPI + 1;

	__smp_cross_call(target, sgi);
}

static inline
void handle_IPI_pipelined(int sgi, struct pt_regs *regs)
{
	unsigned int ipinr, irq;
	unsigned long *pmsg;

	if (sgi) {		/* SGI1-2 */
		irq = sgi + NR_IPI - 1 + OOB_IPI_BASE;
		generic_pipeline_irq(irq, regs);
		return;
	}

	/* In-band IPI (0..NR_IPI - 1) multiplexed over SGI0. */
	pmsg = raw_cpu_ptr(&amp;ipi_messages);
	while (*pmsg) {
		ipinr = ffs(*pmsg) - 1;
		clear_bit(ipinr, pmsg);
		irq = OOB_IPI_BASE + ipinr;
		generic_pipeline_irq(irq, regs);
	}
}
</code></pre></div><p>As illustrated in the example of <a href="https://the-going.github.io/evlproject/ru/dovetail/porting/irqflow/#arch-do-irq">in-band delivery glue code</a>, the
ARM ports distinguishes between device IRQs and IPIs based on the
pipelined IRQ number, with anything in the range
[OOB_IPI_BASE..OOB_IPI_BASE + 10] being dispatched as an IPI to the
<code>__handle_IPI()</code> routine.</p>
<p>Since out-of-band IPI messages are supposed to be exclusively handled
by <a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/irq_handling/">out-of-band handlers</a>, <code>__handle_IPI()</code> is
not required to handle them specifically.</p>
<h4 id="since-kernel-v510-rc6-1">Since kernel v5.10-rc6</h4>
<p>The resulting mapping is as follows:</p>
<table>
<thead>
<tr>
<th style="text-align:center">IPI Message</th>
<th style="text-align:center">Logical IPI number</th>
<th style="text-align:center">Physical SGI number</th>
<th style="text-align:center">Pipelined IRQ number</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IPI_WAKEUP</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">ipi_irq_base</td>
</tr>
<tr>
<td style="text-align:center">IPI_TIMER</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">ipi_irq_base</td>
</tr>
<tr>
<td style="text-align:center">IPI_RESCHEDULE</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">ipi_irq_base</td>
</tr>
<tr>
<td style="text-align:center">IPI_CALL_FUNC</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">ipi_irq_base</td>
</tr>
<tr>
<td style="text-align:center">IPI_CPU_STOP</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">ipi_irq_base</td>
</tr>
<tr>
<td style="text-align:center">IPI_IRQ_WORK</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">ipi_irq_base</td>
</tr>
<tr>
<td style="text-align:center">IPI_COMPLETION</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">ipi_irq_base</td>
</tr>
<tr>
<td style="text-align:center">IPI_CPU_BACKTRACE</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0</td>
<td style="text-align:center">ipi_irq_base</td>
</tr>
<tr>
<td style="text-align:center">TIMER_OOB_IPI</td>
<td style="text-align:center">x</td>
<td style="text-align:center">1</td>
<td style="text-align:center">ipi_irq_base + 1</td>
</tr>
<tr>
<td style="text-align:center">RESCHEDULE_OOB_IPI</td>
<td style="text-align:center">x</td>
<td style="text-align:center">2</td>
<td style="text-align:center">ipi_irq_base + 2</td>
</tr>
</tbody>
</table>
<p>The implementation of the IPI multiplexing for ARM takes place in
<code>arch/arm/kernel/smp.c</code>:</p>
<ul>
<li>
<p>ipi_irq_base stands for the first logical interrupt number assigned
to the series of SGIs. All in-band IPIs are multiplexed over SGI0,
therefore all of them are signaled by IRQ #ipi_irq_base.</p>
</li>
<li>
<p>on the issuer side, <code>smp_cross_call()</code> deals with in-band IPIs
exclusively, logging them into a per-CPU global bitmask
(<code>ipi_messages</code>) before issuing SGI0. <code>irq_send_oob_ipi()</code>
sends out-of-band IPIs by triggering SGI1 (TIMER_OOB_IPI) or SGI2
(RESCHEDULE_OOB_IPI).</p>
</li>
<li>
<p>upon receipt of SGI0, the in-band IPI handler (<code>ipi_handler</code>)
iterates over the pending in-band IPIs by reading the per-CPU
bitmask (<code>ipi_messages</code>) pushing each demultiplexed IRQ event to the
pipeline entry, see <a href="https://the-going.github.io/evlproject/ru/dovetail/porting/irqflow/#genirq-flow">generic_pipeline_irq()</a>. If SGI1 or SGI2 are
received instead, the incoming event is remapped to either
TIMER_OOB_IPI or RESCHEDULE_OOB_IPI before it is fed into the
pipeline.</p>
</li>
</ul>

<div class="notices note">
    <div class="label">Заметка</div><p>There is no generic out-of-band IPI handler: since each IPI has a
dedicated interrupt descriptor, the out-of-band code may request it
directly, installing its own handler by a call to <a href="https://the-going.github.io/evlproject/ru/dovetail/pipeline/irq_handling/">__request_percpu_irq()</a>.</p>

</div>
<div class="highlight"><pre tabindex="0" style="color:#2f1e2e;background-color:#e7e9db;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">static DEFINE_PER_CPU(unsigned long, ipi_messages);

static void smp_cross_call(const struct cpumask *target, unsigned int ipinr)
{
	unsigned int cpu;

	/* regular in-band IPI (multiplexed over SGI0). */
	for_each_cpu(cpu, target)
		set_bit(ipinr, &amp;per_cpu(ipi_messages, cpu));

	wmb();
	__smp_cross_call(target, 0);
}

static irqreturn_t ipi_handler(int irq, void *data)
{
	unsigned long *pmsg;
	unsigned int ipinr;

	/*
	 * Decode in-band IPIs (0..MAX_IPI - 1) multiplexed over
	 * SGI0. Out-of-band IPIs (SGI1, SGI2) have their own
	 * individual handler.
	 */
	pmsg = raw_cpu_ptr(&amp;ipi_messages);
	while (*pmsg) {
		ipinr = ffs(*pmsg) - 1;
		clear_bit(ipinr, pmsg);
		__this_cpu_inc(ipi_counts[ipinr]);
		do_handle_IPI(ipinr);
	}

	return IRQ_HANDLED;
}
</code></pre></div><hr>
<p style="text-align:right">Последнее изменение: Wed, 27 Jun 2018 17:07:51 &#43;0200

	
		
		content/dovetail/porting/arch.md

		
		f22892e

	
</p>


          <footer class="footline">
          </footer>
        </main>
      </div>
      <div id="navigation">
        <a class="nav nav-prev" href="https://the-going.github.io/evlproject/ru/dovetail/porting/atomic/" title="Атомарные операции"><i class="fa fa-chevron-left"></i></a>
        <a class="nav nav-next" href="https://the-going.github.io/evlproject/ru/dovetail/porting/timer/" title="Tick devices"><i class="fa fa-chevron-right"></i></a>
      </div>
    </div>
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="https://the-going.github.io/evlproject/js/clipboard.min.js?1636572175"></script>
    <script src="https://the-going.github.io/evlproject/js/perfect-scrollbar.min.js?1636572175"></script>
    <script src="https://the-going.github.io/evlproject/js/perfect-scrollbar.jquery.min.js?1636572175"></script>
    <script src="https://the-going.github.io/evlproject/js/jquery.svg.pan.zoom.js?1636572175"></script>
    <script src="https://the-going.github.io/evlproject/js/featherlight.min.js?1636572175"></script>
    <script src="https://the-going.github.io/evlproject/js/modernizr.custom-3.6.0.js?1636572175"></script>
    <script src="https://the-going.github.io/evlproject/js/relearn.js?1636572175"></script>
  </body>
</html>
